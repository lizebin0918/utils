1.日期类型存储生日，找到1月生日的用户（不能用函数，无法走索引）
2.cpu跑满，定位线程，怎么定位代码，线程栈有几个状态？
3.开启事务，查询对应的值等于1，更新成2，再查询是2，用MVCC解释
4.concurrenthashmap怎么保证线程安全
5.AQS怎么保证可重入
6.100个数，3个线程顺序打印，线程1打印1，线程2打印2，线程3打印3，线程1打印4...
7.tcp怎么保证可靠传输
8.高并发领取优惠券，库存数怎么保证缓存和数据库一致？最大领券数除了用分布式锁（锁了一个大事务），还有什么方法？
9.2pc和3pc区别
10.解释synchronized和volatile
	* volatile:
	1.每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写会了，他其他已经读取的线程的变量副本就会失效了，需要都数据进行操作又要再次去主内存中读取了。
	2.volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。
	3.volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障。
	4.每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址呗修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。
	5.MESI 的核心思想:modified（修改）、exclusive（互斥）、share（共享）、invalid（无效）
		CPU1使用共享数据时会先数据拷贝到CPU1缓存中,然后置为独占状态(E)，这时CPU2也使用了共享数据，也会拷贝也到CPU2缓存中。通过总线嗅探机制，当该CPU1监听总线中其他CPU对内存进行操作，此时共享变量在CPU1和CPU2两个缓存中的状态会被标记为共享状态(S)；
		若CPU1将变量通过缓存回写到主存中，需要先锁住缓存行，此时状态切换为（M），向总线发消息告诉其他在嗅探的CPU该变量已经被CPU1改变并回写到主存中。接收到消息的其他CPU会将共享变量状态从（S）改成无效状态（I），缓存行失效。若其他CPU需要再次操作共享变量则需要重新从内存读取。
	6.嗅探机制
		每个处理器会通过嗅探器来监控总线上的通知数据，来检查自己缓存内的数据是否过期，如果发现自己缓存行对应的地址被修改了，就会将此缓存行置为无效。当处理器对此数据进行操作时，就会重新从主内存中读取数据到缓存行。(这个过程是系统发出通知，每个处理器自己嗅探是否有数据)
	7.缓存一致性流量
		通过前面都知道了缓存一致性协议，比如MESI会触发嗅探器进行数据传播。当有大量的volatile 和cas 进行数据修改的时候就会产大量嗅探消息。
